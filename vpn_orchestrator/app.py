import osimport ioimport zipfileimport jsonfrom flask import Flask, request, send_file, render_template, jsonifyapp = Flask(__name__)# ==============================================================================# LÓGICA DE INGENIERÍA DE RED (VPN CALCULATION)# ==============================================================================def cidr_to_ip_mask(cidr):    """    Convierte notación CIDR (10.10.10.0/24) a formato IP Máscara (10.10.10.0 255.255.255.0).    Crítico para: Phase 2 Selectors, Address Objects y Static Routes en FortiGate.    """    if not cidr: return "0.0.0.0 0.0.0.0"    try:        # Si ya viene sin barra, asumimos que es algo raro o ya formateado, devolvemos tal cual o arreglamos        if '/' not in cidr:             # Si parece una IP sola, le pegamos una mascara /32 por seguridad, o devolvemos error            return f"{cidr} 255.255.255.255"                    ip_addr, mask_len = cidr.split('/')        mask_len = int(mask_len)        mask = (0xffffffff << (32 - mask_len)) & 0xffffffff        mask_str = ".".join(str((mask >> i) & 0xff) for i in [24, 16, 8, 0])        return f"{ip_addr} {mask_str}"    except: return f"{cidr}"def get_pa_crypto_config(profile):    config = {        "DES-SHA256": {"encryption": ["des"], "hash": ["sha256"], "esp_encryption": ["des"], "esp_authentication": ["sha256"]},        "AES128-SHA256": {"encryption": ["aes-128-cbc"], "hash": ["sha256"], "esp_encryption": ["aes-128-cbc"], "esp_authentication": ["sha256"]},        "AES256-SHA256": {"encryption": ["aes-256-cbc"], "hash": ["sha256"], "esp_encryption": ["aes-256-cbc"], "esp_authentication": ["sha256"]},    }    return config.get(profile, config["AES128-SHA256"])def get_fg_crypto_proposal(profile):    config = {        "DES-SHA256": "des-sha256",        "AES128-SHA256": "aes128-sha256",        "AES256-SHA256": "aes256-sha256",    }    return config.get(profile, config["AES128-SHA256"])# ==============================================================================# GENERADORES DE YAML (ANSIBLE TEMPLATES)# ==============================================================================def generate_hosts_yml(data):    return f"""all:  children:    fortigates:      hosts:        forti_site_a:          ansible_host: {data['fg_mgmt_ip']}          ansible_user: "{data['fg_user']}"          ansible_password: "{data['fg_password']}"          ansible_connection: local          ansible_network_os: fortinet.fortios.fortios          ansible_httpapi_use_ssl: yes          ansible_httpapi_validate_certs: no          ansible_httpapi_port: 443    paloaltos:      hosts:        palo_site_b:          ansible_host: {data['pa_mgmt_ip']}          ansible_user: "{data['pa_user']}"          ansible_password: "{data['pa_password']}"          ansible_connection: local"""def generate_group_vars_all_yml(data, pa_crypto):    # Calcular mascaras locales    fg_lan1_ip_mask = cidr_to_ip_mask(data['fg_lan1_cidr'])    fg_lan2_ip_mask = cidr_to_ip_mask(data['fg_lan2_cidr'])        # Calcular mascaras remotas (CRÍTICO para rutas estáticas en FortiOS)    fg_remote_lan1_ip_mask = cidr_to_ip_mask(data['pa_lan1_cidr'])    fg_remote_lan2_ip_mask = cidr_to_ip_mask(data['pa_lan2_cidr'])        fg_remote_gw = data.get('pa_remote_wan_ip', '10.100.100.115')    fg_remote_tunnel_ip = data.get('pa_remote_tunnel_ip', '169.255.1.2')    pa_peer_ip = data.get('fg_remote_wan_ip', '10.100.100.151')    pa_nexthop_ip = data.get('fg_remote_tunnel_ip_pa', '169.255.1.1')    psk = data['psk'].replace("'", "").replace('"', "")    return f"""# --- GLOBAL ---vpn_name: "{data['tunnel_name']}"vpn_psk: "{psk}" # --- CRYPTO ---phase1_proposal: "{get_fg_crypto_proposal(data['crypto_profile'])}"phase2_proposal: "{get_fg_crypto_proposal(data['crypto_profile'])}"dh_group: "{data['dh_group']}"pa_enc_algo: "{pa_crypto['esp_encryption'][0]}"pa_auth_algo: "{pa_crypto['esp_authentication'][0]}"# --- FORTIGATE SITE A ---fg_wan_intf: "{data['fg_wan_intf']}"fg_lan1_intf: "{data['fg_lan1_intf']}"fg_lan2_intf: "{data['fg_lan2_intf']}"fg_wan_ip: "{data['fg_wan_ip']}" fg_vdom: "{data.get('fg_vdom_name', 'root')}"# Subnets Locales (Formato IP Mask)fg_lan1_cidr: "{fg_lan1_ip_mask}" fg_lan2_cidr: "{fg_lan2_ip_mask}"# Subnets Remotas (Formato CIDR Original para Nombres)fg_remote_lan1_cidr: "{data['pa_lan1_cidr']}" fg_remote_lan2_cidr: "{data['pa_lan2_cidr']}"# Subnets Remotas (Formato IP Mask para Rutas/Config) - NUEVOfg_remote_lan1_mask: "{fg_remote_lan1_ip_mask}"fg_remote_lan2_mask: "{fg_remote_lan2_ip_mask}"fg_tunnel_ip: "{data['fg_tunnel_ip']} 255.255.255.255"fg_remote_tunnel_ip: "{fg_remote_tunnel_ip} 255.255.255.255"fg_remote_gw: "{fg_remote_gw}" # --- PALO ALTO SITE B ---pa_wan_intf: "{data['pa_wan_intf']}"pa_lan1_intf: "{data['pa_lan1_intf']}"pa_lan2_intf: "{data['pa_lan2_intf']}"pa_zone: "{data.get('pa_zone_name', 'VPN_Zone')}"pa_lan1_cidr: "{data['pa_lan1_cidr']}"pa_lan2_cidr: "{data['pa_lan2_cidr']}"pa_remote_lan1_cidr: "{data['fg_lan1_cidr']}" pa_remote_lan2_cidr: "{data['fg_lan2_cidr']}"pa_wan_ip: "{data['pa_wan_ip']}"pa_tunnel_ip: "{data['pa_tunnel_ip']}/32"pa_peer_ip: "{pa_peer_ip}" pa_nexthop_ip: "{pa_nexthop_ip}"pa_provider:  ip_address: "{data['pa_mgmt_ip']}"  username: "{data['pa_user']}"  password: "{data['pa_password']}""""def generate_site_yml(data):    # CORRECCIÓN IMPORTANTE:    # Usamos sintaxis YAML estándar para listas de diccionarios: [{'key': 'value'}]    # Las dobles llaves {{ }} son SOLO para variables de Ansible.    # Los objetos estáticos como {'name': 'all'} ahora van limpios.        return f"""---# ==============================================================================# BEST PRACTICES BASED ON FORTINET TECH TIP 281924 (Route-Based VPN)# ==============================================================================- name: Configurar Overlay FortiGate  hosts: fortigates  connection: local  gather_facts: no  collections:    - fortinet.fortios  vars_files:    - group_vars/all.yml  tasks:    - name: Check API Availability      ansible.builtin.wait_for:        host: "{{{{ fg_wan_ip }}}}"        port: 443        timeout: 5      delegate_to: localhost      ignore_errors: yes    - name: Configurar VPN Phase 1 (IKE Gateway)      fortios_vpn_ipsec_phase1_interface:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        vpn_ipsec_phase1_interface:          name: "{{{{ vpn_name }}}}"          interface: "{{{{ fg_wan_intf }}}}"           ike_version: "2"          peertype: "any"          net_device: "disable"          proposal: "{{{{ phase1_proposal }}}}"          dhgrp: "{{{{ dh_group }}}}"          remote_gw: "{{{{ fg_remote_gw }}}}"           psksecret: "{{{{ vpn_psk }}}}"          nattraversal: "disable"    - name: Configurar VPN Phase 2 (IPsec SA)      fortios_vpn_ipsec_phase2_interface:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        vpn_ipsec_phase2_interface:          name: "{{{{ vpn_name }}}}-P2"          phase1name: "{{{{ vpn_name }}}}"          proposal: "{{{{ phase2_proposal }}}}"          dhgrp: "{{{{ dh_group }}}}"          keylifeseconds: 3600          src_subnet: "0.0.0.0 0.0.0.0"           dst_subnet: "0.0.0.0 0.0.0.0"          auto_negotiate: "enable"    - name: Configurar Interfaz Túnel (VTI)      fortios_system_interface:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        system_interface:          name: "{{{{ vpn_name }}}}"          vdom: "{{{{ fg_vdom }}}}"          type: "tunnel"          interface: "{{{{ vpn_name }}}}"           ip: "{{{{ fg_tunnel_ip }}}}"                  remote_ip: "{{{{ fg_remote_tunnel_ip }}}}"          allowaccess: "ping"    - name: Crear Objeto de Dirección para LAN Remota 1      fortios_firewall_address:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        firewall_address:            # Nombre usa CIDR para legibilidad (Reemplaza / por _)            name: "PA_LAN1_{{{{ fg_remote_lan1_cidr | regex_replace('/', '_') }}}}"            # Subnet usa formato MASCARA DECIMAL (Requerido por FortiOS)            subnet: "{{{{ fg_remote_lan1_mask }}}}"     - name: Crear Objeto de Dirección para LAN Remota 2      fortios_firewall_address:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        firewall_address:            name: "PA_LAN2_{{{{ fg_remote_lan2_cidr | regex_replace('/', '_') }}}}"            subnet: "{{{{ fg_remote_lan2_mask }}}}"     - name: Ruta hacia Site B (LAN 1)      fortios_router_static:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        router_static:          seq_num: "10"          dst: "{{{{ fg_remote_lan1_mask }}}}"                device: "{{{{ vpn_name }}}}"    - name: Ruta hacia Site B (LAN 2)      fortios_router_static:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        router_static:          seq_num: "11"          dst: "{{{{ fg_remote_lan2_mask }}}}"          device: "{{{{ vpn_name }}}}"    # AQUÍ ESTABA EL ERROR: Corregido para usar sintaxis YAML pura para listas de diccionarios    - name: Politica Salida (LAN -> VPN)      fortios_firewall_policy:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        firewall_policy:          policyid: "100"          name: "LAN-to-VPN"          srcintf:            - name: "{{{{ fg_lan1_intf }}}}"            - name: "{{{{ fg_lan2_intf }}}}"          dstintf:            - name: "{{{{ vpn_name }}}}"          # Fix: Usar sintaxis de lista YAML estándar          srcaddr: [{{{{'name': 'all'}}}}]          dstaddr: [{{{{'name': "PA_LAN1_{{{{ fg_remote_lan1_cidr | regex_replace('/', '_') }}}}"}}}}, {{{{ 'name': "PA_LAN2_{{{{ fg_remote_lan2_cidr | regex_replace('/', '_') }}}}"}}}}]          action: "accept"          schedule: "always"          service: [{{{{'name': 'ALL'}}}}]          nat: "disable"           logtraffic: "all"    - name: Politica Entrada (VPN -> LAN)      fortios_firewall_policy:        vdom: "{{{{ fg_vdom }}}}"        state: "present"        firewall_policy:          policyid: "101"          name: "VPN-to-LAN"          srcintf:            - name: "{{{{ vpn_name }}}}"          dstintf:            - name: "{{{{ fg_lan1_intf }}}}"            - name: "{{{{ fg_lan2_intf }}}}"          # Fix: Usar sintaxis de lista YAML estándar          srcaddr: [{{{{'name': "PA_LAN1_{{{{ fg_remote_lan1_cidr | regex_replace('/', '_') }}}}"}}}}, {{{{ 'name': "PA_LAN2_{{{{ fg_remote_lan2_cidr | regex_replace('/', '_') }}}}"}}}}]          dstaddr: [{{{{'name': 'all'}}}}]          action: "accept"          schedule: "always"          service: [{{{{'name': 'ALL'}}}}]          nat: "disable"           logtraffic: "all"- name: Configurar Overlay Palo Alto (Route-Based)  hosts: paloaltos  connection: local  gather_facts: no  collections:    - paloaltonetworks.panos  vars_files:    - group_vars/all.yml  tasks:    - name: Configurar Interfaz Túnel      panos_interface:        provider: "{{{{ pa_provider }}}}"        if_name: "tunnel.1"         mode: "layer3"        ip: ["{{{{ pa_tunnel_ip }}}}"]        vr_name: "default"        zone_name: "{{{{ pa_zone }}}}"        commit: False    - name: Perfil IKE      panos_ike_crypto_profile:        provider: "{{{{ pa_provider }}}}"        name: "{{{{ vpn_name }}}}-IKE"        dh_group: ["group{{{{ dh_group }}}}"]        encryption: ["{{{{ pa_enc_algo }}}}"]        hash: ["{{{{ pa_auth_algo }}}}"]        lifetime_seconds: 43200        commit: False    - name: Perfil IPsec      panos_ipsec_profile:        provider: "{{{{ pa_provider }}}}"        name: "{{{{ vpn_name }}}}-IPSEC"        dh_group: "group{{{{ dh_group }}}}"        esp_encryption: ["{{{{ pa_enc_algo }}}}"]        esp_authentication: ["{{{{ pa_auth_algo }}}}"]        lifetime_seconds: 3600        commit: False    - name: IKE Gateway      panos_ike_gateway:        provider: "{{{{ pa_provider }}}}"        name: "{{{{ vpn_name }}}}-GW"        version: "ikev2"        interface: "{{{{ pa_wan_intf }}}}"            peer_ip: "{{{{ pa_peer_ip }}}}"        pre_shared_key: "{{{{ vpn_psk }}}}"        ikev2_crypto_profile: "{{{{ vpn_name }}}}-IKE"        enable_liveness_check: true        liveness_check_interval: 5        commit: False    - name: IPSec Tunnel      panos_ipsec_tunnel:        provider: "{{{{ pa_provider }}}}"        name: "{{{{ vpn_name }}}}"        tunnel_interface: "tunnel.1"        ike_gw: "{{{{ vpn_name }}}}-GW"        ipsec_profile: "{{{{ vpn_name }}}}-IPSEC"        enable_tunneling: true        commit: False    - name: Proxy ID      panos_config_element:        provider: "{{{{ pa_provider }}}}"        xpath: "/config/devices/entry[@name='localhost.localdomain']/network/tunnel/ipsec/entry[@name='{{{{ vpn_name }}}}']/auto-key/proxy-id"        element: |          <entry name="Wildcard-S2S">            <local>0.0.0.0/0</local>            <remote>0.0.0.0/0</remote>          </entry>        commit: False    - name: Ruta Estática LAN 1 (a FG)      panos_static_route:        provider: "{{{{ pa_provider }}}}"        name: "Ruta-a-FG-LAN1"        destination: "{{{{ pa_remote_lan1_cidr }}}}"         nexthop_type: "ip-address"        nexthop: "{{{{ pa_nexthop_ip }}}}"        interface: "tunnel.1"        virtual_router: "default"        commit: False    - name: Ruta Estática LAN 2 (a FG)      panos_static_route:        provider: "{{{{ pa_provider }}}}"        name: "Ruta-a-FG-LAN2"        destination: "{{{{ pa_remote_lan2_cidr }}}}"         nexthop_type: "ip-address"        nexthop: "{{{{ pa_nexthop_ip }}}}"        interface: "tunnel.1"        virtual_router: "default"        commit: False            - name: Crear Zona VPN si no existe      panos_zone:        provider: "{{{{ pa_provider }}}}"        zone: "{{{{ pa_zone }}}}"        mode: layer3        interface: ['tunnel.1']        commit: False    - name: Policy Trust-VPN (Salida)      panos_security_rule:        provider: "{{{{ pa_provider }}}}"        rule_name: "Permitir_Salida_{{{{ vpn_name }}}}"        source_zone: ["trust"]        destination_zone: ["{{{{ pa_zone }}}}"]        source_ip: ["any"]        destination_ip: ["{{{{ pa_remote_lan1_cidr }}}}", "{{{{ pa_remote_lan2_cidr }}}}"]        action: "allow"        commit: False    - name: Policy VPN-Trust (Entrada)      panos_security_rule:        provider: "{{{{ pa_provider }}}}"        rule_name: "Permitir_Entrada_{{{{ vpn_name }}}}"        source_zone: ["{{{{ pa_zone }}}}"]        destination_zone: ["trust"]        source_ip: ["{{{{ pa_remote_lan1_cidr }}}}", "{{{{ pa_remote_lan2_cidr }}}}"]        destination_ip: ["any"]        action: "allow"        commit: False    - name: COMMIT      panos_commit:        provider: "{{{{ pa_provider }}}}""""# ==============================================================================# RUTAS DEL SERVIDOR FLASK# ==============================================================================@app.route('/')def index():    return render_template('frontend.html')@app.route('/generate', methods=['POST'])def generate():    try:        data = request.json        if "'" in data.get('psk', '') or '"' in data.get('psk', ''):            return "Error: La PSK contiene caracteres no permitidos.", 400        pa_crypto_config = get_pa_crypto_config(data['crypto_profile'])        files_to_zip = {            "vpn_ansible_config/inventory/hosts.yml": generate_hosts_yml(data),            "vpn_ansible_config/group_vars/all.yml": generate_group_vars_all_yml(data, pa_crypto_config),            "vpn_ansible_config/site.yml": generate_site_yml(data),            "vpn_ansible_config/ansible.cfg": """[defaults]inventory=./inventory/hosts.ymlhost_key_checking=Falsetimeout=30"""        }        zip_buffer = io.BytesIO()        with zipfile.ZipFile(zip_buffer, 'a', zipfile.ZIP_DEFLATED, False) as zip_file:            for filename, content in files_to_zip.items():                zip_file.writestr(filename, content.encode('utf-8'))                zip_buffer.seek(0)                return send_file(            zip_buffer,            mimetype='application/zip',            as_attachment=True,            download_name='vpn_ansible_config.zip'        )    except Exception as e:        return str(e), 500if __name__ == '__main__':    app.run(host='0.0.0.0', port=5000, debug=True)